<!DOCTYPE html>
<html lang="zh-Hant-TW">

<head>
    <meta charset="utf-8" />
    <title>Leaflet.SimpleLocate - Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="dist/leaflet-simple-locate.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/low-pass-filter@1.0.0/dist/low-pass-filter.min.js"></script>

    <link rel="stylesheet" href="examples/demo.css" />
    <link rel="stylesheet" href="examples/style.css" />

</head>

<body>
    <div id="map"></div>
    <script>
        "use strict";

        // Harita ve koordinat tanımları
        const mapInfo = {
            viewBox: {
                width: 8206,
                height: 10713
            },
            coordinates: {
                maxLat: 41.30582, // Lat1
                minLat: 41.24312, // Lat2
                maxLng: 28.7609,  // Long1
                minLng: 28.6973   // Long2
            }
        };

        let floorsData = {}; // floor_altitudes.json içeriği buraya yüklenecek
        let currentFloorLines = []; // Mevcut katın kapı (line) çizgileri burada tutulacak

        // floor_altitudes.json dosyasını yükleme fonksiyonu
        async function loadFloorAltitudes() {
            try {
                const response = await fetch('floor_altitudes.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                floorsData = await response.json();
                console.log("Kat yükseklikleri başarıyla yüklendi:", floorsData);
            } catch (error) {
                console.error("Kat yükseklikleri dosyası yüklenirken hata:", error);
            }
        }

        // SVG yerel koordinatlarını LatLng'ye çevirme fonksiyonu
        function localCoordinateToLatLng(x, y) {
            const { maxLat, minLat, maxLng, minLng } = mapInfo.coordinates;
            const { width, height } = mapInfo.viewBox;

            const latDiff = maxLat - minLat;
            const lngDiff = maxLng - minLng;

            const latLocalDiff = (y / height) * latDiff;
            const lngLocalDiff = (x / width) * lngDiff;

            const lat = maxLat - latLocalDiff; // SVG y koordinatı yukarıdan aşağıya artar, LatLng ise aşağıya doğru azalır
            const lng = minLng + lngLocalDiff;

            return new L.LatLng(lat, lng);
        }

        // Altitude'a en yakın katı ve SVG'sini çeken ve parse eden fonksiyon
        async function fetchAndParseSVGForAltitude(altitude) {
            let closestFloor = null;
            let minAltitudeDiff = Infinity;

            for (const floorKey in floorsData) {
                const floor = floorsData[floorKey];
                const diff = Math.abs(altitude - floor.altitude);
                if (diff < minAltitudeDiff) {
                    minAltitudeDiff = diff;
                    closestFloor = floor;
                    closestFloor.key = floorKey; // Kat anahtarını da ekle (D, EP, vb.)
                }
            }

            if (closestFloor) {
                console.log(`Altitude (${altitude}) değerine en yakın kat: ${closestFloor.key} (Altitude: ${closestFloor.altitude})`);
                try {
                    const response = await fetch(closestFloor.svg);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const svgText = await response.text();
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, "image/svg+xml");

                    const doorsGroup = svgDoc.getElementById('Doors');
                    if (doorsGroup) {
                        // 'path' yerine 'line' elementlerini alıyoruz
                        const lines = doorsGroup.getElementsByTagName('line'); 
                        const linesArray = [];
                        Array.from(lines).forEach(line => {
                            const id = line.id;
                            // Doğrudan x1, y1, x2, y2 niteliklerini alıyoruz
                            const x1 = parseFloat(line.getAttribute('x1'));
                            const y1 = parseFloat(line.getAttribute('y1'));
                            const x2 = parseFloat(line.getAttribute('x2'));
                            const y2 = parseFloat(line.getAttribute('y2'));
                            
                            // Kontrol ekleyelim, null veya NaN olmamalı
                            if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
                                console.warn(`Line '${id}' için geçersiz koordinat değerleri: x1=${x1}, y1=${y1}, x2=${x2}, y2=${y2}`);
                                return; // Bu çizgiyi atla
                            }

                            const startLatLng = localCoordinateToLatLng(x1, y1);
                            const endLatLng = localCoordinateToLatLng(x2, y2);

                            linesArray.push({
                                id,
                                start: { lat: startLatLng.lat, lng: startLatLng.lng },
                                end: { lat: endLatLng.lat, lng: endLatLng.lng },
                                floor: closestFloor.key // Hangi kata ait olduğunu da ekleyelim
                            });
                        });
                        currentFloorLines = linesArray; // Mevcut katın kapılarını güncelle
                        return { lines: linesArray, floorKey: closestFloor.key };
                    } else {
                        console.warn(`'Doors' grubu '${closestFloor.svg}' içinde bulunamadı.`);
                        currentFloorLines = [];
                        return { lines: [], floorKey: closestFloor.key };
                    }
                } catch (error) {
                    console.error(`SVG dosyası yüklenirken veya parse edilirken hata (${closestFloor.svg}):`, error);
                    currentFloorLines = [];
                    return { lines: [], floorKey: closestFloor.key };
                }
            } else {
                console.warn("Altitude değerine uygun bir kat bulunamadı.");
                currentFloorLines = [];
                return { lines: [], floorKey: null };
            }
        }

        // Harita başlatma
        const map = new L.Map("map", {
            center: [(mapInfo.coordinates.maxLat + mapInfo.coordinates.minLat) / 2, (mapInfo.coordinates.maxLng + mapInfo.coordinates.minLng) / 2],
            zoom: 18,
            zoomControl: false,
        });

        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const control = new L.Control.SimpleLocate({
            position: "topleft",

            medianWindowSize: 7,
            kalmanProcessNoise: 0.01,
            kalmanMeasurementNoise: 0.1,
            jumpThreshold: 0.0001,
            showFilterInfo: false,
            enableFiltering: true,
            showFilterDebug: false,
            showJumpWarnings: true,
            lowPassFilterTau: 1.0,
            enableLowPassFilter: true,

            afterDeviceMove: async (location) => {
                let lat = location.lat;
                let lng = location.lng;
                let accuracy = location.accuracy;
                let altitude = location.altitude; // SimpleLocate'den gelen altitude bilgisi

                // Eğer altitude bilgisi SimpleLocate'den gelmiyorsa veya geçersizse, varsayılan değer kullan
                if (typeof altitude === 'undefined' || isNaN(altitude) || altitude === null) {
                    if (Object.keys(floorsData).length > 0) {
                        // Yüklü kat bilgisi varsa ilk katın altitude'unu varsayılan al
                        altitude = floorsData[Object.keys(floorsData)[0]].altitude; 
                    } else {
                        altitude = 1150; // Hiçbir kat bilgisi yoksa sabit bir varsayılan
                        console.warn("Altitude bilgisi bulunamadı, varsayılan değer (1150) kullanılıyor.");
                    }
                }

                if (accuracy > 50) {
                    if (!window.lowAccuracyWarningShown || (Date.now() - window.lastLowAccuracyWarningTime > 30000)) {
                        showAccuracyWarning(accuracy);
                        window.lowAccuracyWarningShown = true;
                        window.lastLowAccuracyWarningTime = Date.now();
                    }
                    checkLocation(lat, lng, altitude); // Düşük doğrulukta bile kontrol et
                } else {
                    window.lowAccuracyWarningShown = false;
                    checkLocation(lat, lng, altitude);

                    if (typeof updateUserPosition === 'function') {
                        const mockPosition = {
                            coords: {
                                latitude: lat,
                                longitude: lng,
                                accuracy: accuracy,
                                altitude: altitude
                            },
                            timestamp: Date.now()
                        };
                        updateUserPosition(mockPosition);
                    }
                }
            },

            afterClick: (status) => {
                console.log("Geolocation status:", status.geolocation);
                console.log("Orientation status:", status.orientation);
                if (!status.geolocation) {
                    showPopup("Konum alınamadı", "red");
                }
            }
        }).addTo(map);

        function showAccuracyWarning(accuracy) {
            const existingWarning = document.querySelector('.accuracy-warning');
            if (existingWarning) {
                existingWarning.remove();
            }

            const warning = document.createElement('div');
            warning.className = 'accuracy-warning';
            warning.innerHTML = `
                <div>Düşük GPS Doğruluğu (±${Math.round(accuracy)}m)</div>
            `;
            document.body.appendChild(warning);

            setTimeout(() => {
                if (warning.parentNode) {
                    warning.remove();
                }
            }, 5000);
        }

        // Wei Ye Algoritması UI kontrolü oluştur
        function createWeiYeInfoControl() {
            const weiYeInfoControl = L.Control.extend({
                options: {
                    position: 'topright'
                },
                _doorInfo: {
                    doorId: null,
                    distance: null,
                    floor: null
                },
                onAdd: function (map) {
                    this._container = L.DomUtil.create('div', 'leaflet-control leaflet-control-wei-ye-info');
                    this._updateContent();
                    L.DomEvent.disableClickPropagation(this._container);
                    return this._container;
                },
                _updateContent: function () {
                    const isMobile = window.innerWidth <= 640;
                    let doorHtml = '';
                    if (this._doorInfo.doorId) {
                        doorHtml = `
                            <div class="wei-ye-door-info">
                                <div>En Yakın: <span class="door-name">${this._doorInfo.doorId}</span> 
                                ${this._doorInfo.floor !== null ? `<div>Kat: ${this._doorInfo.floor}</div>` : ''}
                            </div>
                        `;
                    } else {
                        doorHtml = `
                            <div class="wei-ye-door-info">
                                <div class="no-door">Kapı bilgisi bekleniyor...</div>
                            </div>
                        `;
                    }

                    if (isMobile) {
                        this._container.innerHTML = `
                            <div class="wei-ye-info-panel">
                                <div class="wei-ye-title">Konum Bilgisi</div>
                                <div class="wei-ye-stats">
                                    <div>Doğruluk: <span class="accuracy-value">--</span>m</div>
                                </div>
                                ${doorHtml}
                            </div>
                        `;
                    } else {
                        this._container.innerHTML = `
                            <div class="wei-ye-info-panel">
                                <div class="wei-ye-title">
                                    Konum Bilgisi
                                    <small style="opacity: 0.7; font-weight: normal; font-size: 90%;">Filtrelenmiş</small>
                                </div>
                                <div class="wei-ye-stats">
                                    <div>Doğruluk: <span class="accuracy-value">--</span> m</div>
                                    <div>Durum: <span class="is-filtered">Bekleniyor</span></div>
                                </div>
                                ${doorHtml}
                            </div>
                        `;
                    }
                },
                updateStats: function (stats) {
                    const accuracyEl = this._container.querySelector('.accuracy-value');
                    const filteredEl = this._container.querySelector('.is-filtered');

                    if (accuracyEl && stats.accuracy) {
                        accuracyEl.textContent = Math.round(stats.accuracy);
                        if (stats.accuracy <= 5) {
                            accuracyEl.className = 'accuracy-value accuracy-good';
                        } else if (stats.accuracy <= 15) {
                            accuracyEl.className = 'accuracy-value accuracy-medium';
                        } else if (stats.accuracy <= 30) {
                            accuracyEl.className = 'accuracy-value accuracy-low';
                        } else {
                            accuracyEl.className = 'accuracy-value accuracy-poor';
                        }

                        if (stats.accuracy > 50) {
                            this._container.style.border = '2px solid #F44336';
                            if (filteredEl) {
                                filteredEl.textContent = "Belirsiz Konum";
                                filteredEl.style.color = '#F44336';
                            }
                        } else {
                            this._container.style.border = '';
                            if (filteredEl) {
                                if (stats.isJump) {
                                    filteredEl.textContent = "Sıçrama düzeltildi";
                                    filteredEl.style.color = '#FF9800';
                                    setTimeout(() => {
                                        filteredEl.textContent = "Normal";
                                        filteredEl.style.color = '#4CAF50';
                                    }, 2000);
                                } else if (!stats.initializing) {
                                    filteredEl.textContent = "Normal";
                                    filteredEl.style.color = '#4CAF50';
                                }
                            }
                        }
                    }
                },
                updateDoorInfo: function (doorInfo) {
                    if (doorInfo) {
                        this._doorInfo = doorInfo;
                        this._updateContent();
                    }
                }
            });

            const weiYeInfo = new weiYeInfoControl().addTo(map);

            window.addEventListener('resize', () => {
                const doorInfo = weiYeInfo._doorInfo;
                map.removeControl(weiYeInfo);
                const newWeiYeInfo = new weiYeInfoControl().addTo(map);
                newWeiYeInfo._doorInfo = doorInfo;
                newWeiYeInfo._updateContent();

                // Referansları güncelle
                weiYeInfo._container = newWeiYeInfo._container;
                weiYeInfo._doorInfo = newWeiYeInfo._doorInfo;
                weiYeInfo._updateContent = newWeiYeInfo._updateContent;
            });

            const originalAfterDeviceMove = control.options.afterDeviceMove;
            control.options.afterDeviceMove = function (location) {
                if (originalAfterDeviceMove) {
                    originalAfterDeviceMove(location);
                }

                weiYeInfo.updateStats({
                    accuracy: location.accuracy,
                    isJump: location.isJump,
                    initializing: control._weiYeState?.filteringStats.totalUpdates < 3
                });
            };

            return weiYeInfo;
        }

        const weiYeInfoControl = createWeiYeInfoControl();

        // Konum kontrolü ve en yakın kapıyı bulma fonksiyonu
        async function checkLocation(lat, lng, altitude) {
            console.log("Konum Kontrol Ediliyor:", lat, lng, "Altitude:", altitude);

            // Eğer currentFloorLines boşsa veya doğru katın çizgileri değilse, yeni katı yükle
            // Bu kontrol, sadece kat değiştiğinde veya başlangıçta yeni SVG'yi çekmeyi sağlar
            if (currentFloorLines.length === 0 || 
                (currentFloorLines.length > 0 && currentFloorLines[0].floor !== getClosestFloorKey(altitude))) {
                const { lines, floorKey } = await fetchAndParseSVGForAltitude(altitude);
                currentFloorLines = lines; // Güncel katın çizgilerini ayarla
                if (!floorKey) {
                    console.warn("Geçerli bir kat anahtarı bulunamadı, kapı bilgileri güncellenemiyor.");
                    weiYeInfoControl.updateDoorInfo(null);
                    return;
                }
            }
            
            // Konum harita sınırları içinde mi kontrol et
            const { minLat, maxLat, minLng, maxLng } = mapInfo.coordinates;
            if (lat < minLat || lat > maxLat || lng < minLng || lng > maxLng) {
                console.log("❌ Dışarıda");
                showPopup("❌ Dışarıda", "red");
                weiYeInfoControl.updateDoorInfo(null); // Dışarıdaysa kapı bilgisi gösterme
                return;
            } else {
                console.log("✅ İçeridesiniz");
                findClosestLine(lat, lng, currentFloorLines, getClosestFloorKey(altitude));
            }
        }

        // Altitude'a en yakın kat anahtarını bulan yardımcı fonksiyon
        function getClosestFloorKey(altitude) {
            let closestFloorKey = null;
            let minAltitudeDiff = Infinity;
            for (const floorKey in floorsData) {
                const floor = floorsData[floorKey];
                const diff = Math.abs(altitude - floor.altitude);
                if (diff < minAltitudeDiff) {
                    minAltitudeDiff = diff;
                    closestFloorKey = floorKey;
                }
            }
            return closestFloorKey;
        }

        // En yakın kapıyı bulma fonksiyonu
        function findClosestLine(lat, lng, linesArray, currentFloorKey) {
            let closestLine = null;
            let minDistance = Infinity;

            if (!linesArray || linesArray.length === 0) {
                console.warn("En yakın kapıyı bulmak için kullanılacak çizgi verisi yok.");
                weiYeInfoControl.updateDoorInfo(null);
                return null;
            }

            linesArray.forEach(line => {
                // Leaflet'in kendi distance metodunu kullanarak mesafeyi hesapla (metre cinsinden)
                const startDist = map.distance([lat, lng], [line.start.lat, line.start.lng]);
                const endDist = map.distance([lat, lng], [line.end.lat, line.end.lng]);
                
                // Noktanın bir çizgiye olan en kısa mesafesini bulma (bu daha doğru bir yaklaşımdır)
                // Nokta (lat, lng), çizgi (start.lat, start.lng) - (end.lat, end.lng)
                const p = L.latLng(lat, lng);
                const a = L.latLng(line.start.lat, line.start.lng);
                const b = L.latLng(line.end.lat, line.end.lng);
                
                // Bu kısım için biraz daha karmaşık bir geometri hesaplaması gerekir.
                // Basitlik adına, şimdilik sadece başlangıç ve bitiş noktalarına olan mesafelerin min'i alınsın.
                // Gerçek bir "çizgiye en yakın nokta" hesaplaması için özel bir kütüphane veya daha fazla matematiksel fonksiyon gerekebilir.
                // Şimdilik, mevcut yaklaşımı (başlangıç/bitiş noktalarına olan min mesafe) koruyalım.
                const distanceToLineSegment = Math.min(startDist, endDist);


                if (distanceToLineSegment < minDistance) {
                    minDistance = distanceToLineSegment;
                    closestLine = line;
                }
            });

            if (closestLine) {
                weiYeInfoControl.updateDoorInfo({
                    doorId: closestLine.id,
                    distance: minDistance.toFixed(2), // Mesafeyi 2 ondalık basamağa yuvarla
                    floor: currentFloorKey // `currentFloorKey` parametresini kullan
                });
                return closestLine;
            } else {
                weiYeInfoControl.updateDoorInfo(null);
                return null;
            }
        }

        // Popup gösterme fonksiyonu
        function showPopup(message, color) {
            let popup = L.popup().setLatLng(map.getCenter()).setContent(`<span style="color: ${color}">${message}</span>`).openOn(map);
        }

        // Sayfa yüklendiğinde kat yüksekliklerini yükle
        loadFloorAltitudes();

    </script>
    <script src="dist/line-tracking.js"></script>
</body>

</html>